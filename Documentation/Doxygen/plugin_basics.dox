/**

\page plugin_basics Plugin Basics

In this section we'll see how to start a plugin for FEBio.

\section plugin_sec1 1. Building a plugin

\subsection plugin_sec1_0 What do you need?
In order to build a plugin you need to have the FEBio SDK (Software Developemnt Kit). This SDK contains the header files and the pre-built libraries that you
need to create a plugin. The SDK is usually installed in the same location as FEBio (usually in a subfolder named sdk). Next, you need a C++ compiler since the
plugin has to be written in C++. We also recommend having a IDE (Integrated Development Environment) as this makes writing code much easier (e.g. VS2010 on Windows, or XCode on Mac). 

\subsection plugin_sec1_1 Creating a plugin project in Visual Studio 2010
To create a plugin for FEBio in Visual Studio 2010, you need to create a new dll project. To do this, open Visual Studio 2010 and select File->New->Project from the menu. 
Select the Win32 Project, give it a name and select OK. This will start the Win32 Application Wizard. The first window of the wizard shows the current project settings. 
Select the Next button to customize the settings. In the Application Settings window select DLL for the Application type. Then press Finish to create the new project.

Next, we'll need to tell Visual Studio where to find the FEBio header and library files. To do this, right-click on the project name in the Solution Explorer and select Properties.
Locate the VC++ Directories in the Configuration Properties. In the Include Directories, add the path to the include files (e.g. "C:\Program Files\FEBio2\sdk\include"). Then,
add the path to the FEBio library files to the Library Directories field (e.g. "C:\Program Files\FEBio2\sdk\lib\"). When done, press the OK button.

Now you are ready to write your plugin. You will start by implementing the required functions described below. Before you write these functions, you need to add following include file
to the top of your source file. (If you are using precompiled header files, make sure the precompiled header file (e.g. stdafx.h) is the first included file.)

\code
#include "FECore\FECoreKernel.h"
\endcode

\subsection plugin_sec1_2 Creating a plugin for Linux
A sample plugin, NeoHookeanPI, is included on the FEBio download page.  Review the Makefile for specifics of compiling a plugin on Linux.  The important points are:
- compile with the -fPIC flag.
- link with -shared -Wl,-soname,libname.so where libname is the name of the library.

\subsection plugin_sec1_3 Creating a plugin for Mac
The instructions for the Mac are the same as those for Linux except:
- link with -dynamiclib

\section plugin_sec2 2. Required Functions
The following functions need to be defined in the plugin and are needed for plugin registration, initialization and cleanup. 

\subsection GetSDKVersion
This function returns the version number of the SDK that was used to build the plugin. When loading the plugin FEBio will check this number
to see if the plugin is compatible with the FEBio version that is trying to load the plugin. This function needs to return the
FE_SDK_VERSION macro which is defined in the file FECore\version.h

\code
FECORE_EXPORT unsigned int GetSDKVersion()
{
	return FE_SDK_VERSION;
}
\endcode

FEBio will not load the plugin if this function is omitted or if the returned version number is incompatible with the version of FEBio that is trying to load the plugin.

\subsection PluginInitialize
This function will be the first function called by FEBio and can be used to allocated and initialize plugin data.

\code
FECORE_EXPORT void PluginInitialize(FECoreKernel&);
\endcode

It takes one parameter, a reference to the kernel object. This object is used for accessing the resources managed by this class, such as the \ref plugin_log "log file". This is also a good place to allocate any resources that the plugin may need. 

\subsection PluginNumClasses
This functions returns the number of classes that the plugin defines. 

\code
FECORE_EXPORT int PluginNumClasses();
\endcode

A plugin can contain multiple classes. For example, it can contain a class for a new material that uses internal variables.
In addition, classes for writing the internal variables to the plotfile can be defined as well. This function returns the number of class
(or more correctly, the number of factory classes) that the plugin wants to register with FEBio.

\subsection PluginGetFactory
This function is used to register the individual factory classes with FEBio.

\code
FECORE_EXPORT FECoreFactory* PluginGetFactory(int i);
\endcode

This function will be called as many times as there are factory classes (i.e. the value returned by PluginNumClasses). In each call, it should return
a pointer to a factory class. See section below for more details on how to create a plugin factory class.

\subsection PluginCleanup
This function will be called when FEBio terminates and can be used to deallocate resources.

\code
FECORE_EXPORT void PluginCleanup()
\endcode

\section plugin_sec3 3. Factory Classes
A factory class is a special type of class that is designed to create an instance of a specific class that can be used in FEBio. It has a member function called 
Create() that FEBio will when it needs to instantiate your plugin class. In order for this to work, all factory classes must be registered with the framework. To register
a plugin class, you must instantiate a factory class for each of your plugin classes and then return a pointer to the factory class in the PluginGetFactory method. 

The easiest way to create a factory class is to use the FEPluginFactory_T template class. This template has two arguments, the class name
and the SuperClass ID. In addition, the constructor takes the string name of the class that is to used in the FEBio xml input file. For example, for
a material plugin. You must include the "FECore/FECoreKernel.h" header file.

\code
class MyPluginClass : public FEElasticMaterial {};

FEPluginFactory_T<MyPluginClass, FEMATERIAL_ID> my_factory("my material");
\endcode

Then, in the PluginGetFactory method, you return a pointer to the my_factory object to register the factory class. 

The available SuperClass ID's can be found in "FECore\FE_enum.h". Currently, the following values are defined.
\li FETASK_ID         : Create a task class
\li FEMATERIAL_ID     : Create a material class
\li FEBODYLOAD_ID     : Create a body load class
\li FENLCONSTRAINT_ID : Create a nonlinear constraint class
\li FEPLOTDATA_ID     : Create a plot data class
\li FECALLBACK_ID     : Create a callback class

\section plugin_sec4 4. Using the plugin
In order to use the plugin you have to add it to the FEBio configuration file. This file, usually called "febio.xml", is located in the same place as the executable is.
Add the following line to this configuration file.

\code
<import>c:\path\to\plugin\plugin.dll</import>
\endcode

That is, enclose the full path and filename of the plugin between "import" tags. When FEBio starts it will read all plugins listed in the configuration file. A message will be printed on the screen at the start of an FEBio analysis indicating if FEBio was successful in loading the plugin.

This page was edited last on Mon Jun 20 2015.

*/
