/**
\page callback FEBio callbacks

An easy, although somewhat limited, way to extend FEBio's capabilities is by defining callbacks. A callback is a function
that is defined by the user and is called by the FEBio framework at specific places in the code. 

FEBio uses this callback mechanism to update the title of the shell window to display the progress and to query for user interruptions (ctrl+c). 

To register a callback function, call the FEModel::AddCallback function. 

\code
void FEModel::AddCallback(FEBIO_CB_FNC pcb, FEBIO_CB_WHEN nwhen, void *pd);
\endcode

This function takes three parameters. The first is a pointer to the callback function. This function must be of FEBIO_CB_FNC type which is described below.
The second parameter is a variable of type FEBIO_CB_WHEN that defines when FEBio will call the callback. The third parameter is a void pointer that the user
can use to pass data to the callback. 

The callback function must have the FEBIO_CB_FNC type which is defined as follows.

\code
void (*FEBIO_CB_FNC)(FEModel&, unsigned int, void*);
\endcode

When FEBio calls the function, the first parameter will be a reference to the FE model. The second parameter is the reason why FEBio called this function. Since
callbacks can be called for multiple events, this parameter will contain the explicit reason. The third parameter is the data pointer that was passed
when registering the callback.

The nwhen parameter above can take on the following values.
\li <b>CI_INIT</b>: Call the callback after FEBio is done with initialization (and before the solve phase starts)
\li <b>CB_ALWAYS</b>: Call the callback whenever FEBio calls the callbacks.
\li <b>CB_MAJOR_ITERS</b>: Only call the callback at end of major iterations.
\li <b>CB_MINOR_ITERS</b>: Only call the function at each minor iteration. 

These flags can be combined using bitwise OR. For instance, CB_MAJOR_ITERS | CB_MINOR_ITERS will cause the callback to be called both during the 
major and minor iterstions.

For example, the following code snippet shows how to define a callback that is always called.

\code
void my_cb(FEModel&, unsigned int, void*);

FEModel fem;
fem.AddCallback(my_cb, CB_ALWAYS, 0);
\endcode

Inside the callback function, the reason parameter can be used to determine why the callback was called. 

\code
void my_cb(FEModel& fem, unsigned int nreason, void* pd)
{
	if (nreason & CB_INIT)
	{
		// initialization has finished
	}
	else if (nreason & CB_MAJOR_ITERS)
	{
		// FEBio solved a converged state
	}
	else if (nreason & CB_MINOR_ITERS)
	{
		// a minor iteration has finished
	}
}
\endcode

This page was edited last on Sun Jun 17 2015.
*/
